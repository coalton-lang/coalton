\documentclass[12pt]{article}
\usepackage[]{todonotes}

\newcommand{\code}{\texttt}

\title{The Coalton Standard Library}

\begin{document}

\maketitle
\section{Introduction}
The Coalton standard library is a set of foundational packages that
support practical application development, and are maintained alongside
the core language, sharing a common release and versioning
schedule. This report provides recommendations for the scope,
organization and content of these packages.

\section{General Recommendations}

\subsection{Compact Core}

The core language and compiler should be as small as is reasonable.
When possible, types should be defined in the standard library, rather
than as part of the core language. The core language should have
little need for knowledge about the structure and contents of its
libraries.

\medskip
\underline{Recommendations}

\begin{itemize}
\item Relocate the definition of \code{char} to
  \code{coalton/data/char}, etc.
\end{itemize}

\subsection{Standard and Contributed Libraries}

Outside of the core language implementation, libraries can be
classified as either ``standard'' or ``contributed''.  The standard
library should contain definitions that are frequently used by most
applications written in Coalton, whereas contributed libraries should
contain definitions that support specific application domains, for
instance computer algebra, special kinds of network protocols, or io.

\medskip
\underline{Recommendations}

\begin{itemize}
\item Move parts of \code{coalton-library/math/*} that are not
  relevant to common arithmetic and trigonometric operations with
  primitive types into a contributed library.
\item Build and test contributed libraries in a separate phasea
  subsequent to building the core language and standard library.
\end{itemize}

\subsection{Documentation}

Full documentation is very important for both beginning and advanced
users.

\medskip
\underline{Recommendations}

\begin{itemize}
\item Systematically vet the documentation string of every definition.
\item For each definition, provide a trivial but illustrative example
  with a known output.
\item Provide direct links from generated documentation to
  corresponding, versioned definitions in GitHub.
\end{itemize}

\subsection{Self Sufficiency}

The language should be self sufficient, to the extent that the
standard library is able to self-update, and load contributed
libraries.

\medskip
\underline{Recommendations}

\begin{itemize}
\item Plan to include network protocol and encryption support
  necessary to implement a secure package manager.
\end{itemize}

\subsection{Approachability}

Judge the contents of the standard library in light of commonly used
languages: how different are the core types, data and control
structures? How hard is it to read and write data? How hard is it to
write a CSV parser? Things that sound easy ought to be easy, and this
should be demonstrable.

\medskip
\underline{Recommendations}

\begin{itemize}
\item Provide a rosetta stone comparing Coalton to js, python, etc.
\item Avoid ambiguity resulting from short nicknames, for instance,
  'ORD' for 'ORDER'
\item Avoid terse portmanteau prefixes such as ``mk''.
\item Provide extended data syntax for vectors, maps and sets.
\item Provide regular expression support in the standard library,
  i.e., wrap CL-PPCRE.

\end{itemize}

\section{IO}

\todo {readable data syntax}
Discuss extended data syntax, with proposal to adopt EDN-style
notation for maps and vectors.

\section{Naming}

\subsection{Symbols}

\medskip
\underline{Recommendations}
\begin{itemize}
\item Apply consistent naming to symbols: Python case for classes and instances, lisp-style hyphenation for functions.
\end{itemize}

\subsection{Packages}

The existing packages can have shorter names and better logical grouping.

\medskip
\underline{Recommendations}
\begin{itemize}
\item Replace \code{coalton-library} with \code{coalton}.
\item Define a shallow package hierachy of maximum depth 3, with
  general features at the root, and specific features at the second
  level.
\item Put primitive types under \code{coalton/type}.
\item Put concrete data types under \code{coalton/data}.
\item Put typeclass definitions under \code{coalton/class}.
\item Put system and host resource access under \code{coalton/sys}.
\end{itemize}

\subsubsection{Proposed Layout}

\begin{itemize}
\item coalton
\item coalton/class
\item coalton/class/iterator, monad
\item coalton/class/monad
\item coalton/data
\item coalton/data/array, hash, list, map, queue, seq, tree, tuple, vector
\item coalton/function
\item coalton/math
\item coalton/mutable
\item coalton/sys
\item coalton/sys/{file
\item coalton/type
\item coalton/type/bit, byte, char, string
\end {itemize}

The toplevel packages ('data', 'type') are good places to relocate
type classes that may apply to more than one concrete type.

\subsection{Types}

\subsubsection{Primitive Types}

which types are core types? It may be the best that no types are
primitive types. What Coalton is really providing is abstraction.
\todo{primitive}

should both single and double floats be present in core? In which
languages does this matter? When is the past time that a programmer
reached for a short float? (Answer, recently, all the time: but
they've transcended the short float to demand hardware for bfloats,
and beyond)

\subsubsection{Tuples}

The ought be no need to characterize tuples as Tuple2, Tuple3,
Tupld4. At very least the numerically-suffixed structure classes that
provide tuple storage ought to be obscured by notation.

Tuples receive ordinal accessors (first, second, third).

It may be desirable to support named tuples, to provide better cues
about function.

\todo{question}
Is there a conflict or overlap with coalton-library/struct?

tuples as an existential type.
\todo{what did we mean?}

\subsection{Casting}

There are a lot of disparate casting functions that ought to be
replaced by into -- notable, as below, tointeger.


\subsubsection{coalton-library/math/fraction}

R: mkfraction - the 'mk' prefix is unique here: is there a naming convention to apply?

Q: Fraction is a primitive type, just a wrapper for a lisp fraction, and appears in primitive-types.

N: implementation of primitive types is kind of a mess, for instance
the defvar in typechecker/types.

the type definition should probably be in this file

clearly mark that this is a CL rational

\subsubsection{coalton-library/tuple}

\section{Hashing}

Question: do other languages "expose an interface to hashing."

\todo{note} add example: hashable label type with string-typed label.

\section{ADTs}

loading array into system - doesn't need a tmpfile

write a whole para on traverse. the methods all need descriptions

talk about traversable and sequence

\subsection{Package Audit}

\subsubsection{coalton-library/bits}

Support for bitwise operations. The implementations are present in \code{coalton-library/math/num}.

\medskip
\underline{Recommendations}

\begin{itemize}
\item Rename to \code{coalton/type/bit} to represent that these operations are generally against concrete machine values defined there.
\end{itemize}


ascii - really means utf8 or whatever the platform uses

the char package needs to have all of its assumptions checked

\subsubsection{coalton-library/classes}

This package contains a mixture of comparison (Eq, Ord), control flow
(Optional, Result, Signalable, Unwrappable), and storage (Tuple)
classes.

\medskip
\underline{Recommendations}

\begin{itemize}
\item Relocate tuple definition to \code{coalton/data/tuple}
\item Relocate control flow and error classes to ``coalton/error''
\item Improve tuple documentation ('heterogeneous collection of items')
\end{itemize}

Note: there should be some way to easily define a bit or byte type -
for U7, or whatever particular value. See also notes in ... math bits?
... about taking machine types (U8, I8) and 1 taking their definitions
out of core 2) into a single package in std lib.

N: rationalization of max and min

\subsubsection{coalton-library/math/integral}

Q: tointeger seems to overlap completely with (into Integer ..)
- can it be collapsed? What is the purpose, otherwise?

Q: "to-" prefix: is it like "mk-" prefix?

N: it may be confusing to have multiple (semantically identical)
definitions

Q: Are there problems with integral->num? Can it be killed? It seems
ot only add syntax, in that it could be equally well expressed as
(into X whatever) rather than (the foo (integral->num whatever)).

Q: How sound is semigroup? What is it used for, what does it support?

R: HASH should be a nonexternal library: just provides one method to hash table.

HASH should be in hashtablr files.

There should be documentation here that provides a rationale for a hash user.

\subsubsection{coalton-library/builtin}

Q can the file builtin go away?

undefined can go to functions, the others can all go to boolean.

\subsubsection{coalton-library/functions}

Q /= goes to classes

Q can flip be gotten rid of

Any time there is some arbitrary haskell thing added to a part of the
standard library, there ought to be an example.

Question: trace and trace object need ot be move to format library.

trace

R: The proxy system (or its interface) should be reassessed. Consider
the example of setting the element type when reading a vector.

Q: Booolean: when would you use Ord over Boolean?

R: 'builtin' is chop suey of boolean and debugging: tweeze

Q: are there different 'flavors' of Boolean that should be picked apart?

Q: is there a way to eject builtin types from the typecheckers?

Q:  How much does the typechecker need ot know about primitive types at compile time?

R: "/=" should be in classes, not in fucntions

Question: we need a thin wrapper on lisp format.

Question: format error function

Recommendation: Move dyadic and dual to secondary packages.

Note: bifunctor shouldn't in core, someone can define it as part of
      something they need

There needs to be some docstring for SEQUENCE [FUNCTION] - switches between types of containers

Unwrappable should be its own thing, and the gateway to the condition
system, since it's a way to handle errors.

Optional and result should also go into that file.

The repr for enum types should be exposed in the documentation.

The documentation needs ot be either in file or alphabetical order.

\subsubsection{coalton-library/math/arith}

Note:- bits documentation is outright wrong about the twos complement stuff

Question: define char at the top of this file, not as an 'early type'

    - same for 'string'

nothing needs a char until the car file!

Note: docs should be generated in alphabetical order (or file order!)

Splin N string - > tuple string

Note: unchecked -> unsafe

Question: documentation for all of the macros

Question: where is the documentation for define-struct, define-class, define-instance!

QQ And the lisp form.

Note: car/cdr -> first and rest

NN remanticsd of remove-if are weird - only operates on  fiorts match?

Question: equivalence-classes?

Note: audit fpor "XXX"! with return value + side effects or mutation

Question: It seems like 'cell' should be a pure (atomic?) mutation interface, that doesn'tr have any assumptions about the kind of type to which a reference is being maintained.

Question: is random-access like this? Is r-a something that is stored in cell?

Note: are vectors able to supersede a bunch of other stuff (cell, list)

"implemented by a linked list - what?

Question: Free monad - why are the type variables renamed in the documentation?

NN up-to and down-from are weird.

Question: elementwise-hash! is specialized to the implementation of ord-trees, and belongs there

Question: remove-duplicates! shows up in a weird place and duplicates a documentation section

Note: ord-tree collect! tree - should be into iterator?

Question: ".like replace-or-insert" - do those really have to have names that are so similar?

Q - ord-map - why is there not ord in entries?

R: The SEQ types seems hollowed out or superseded by vector and iterator stuff: does it stay or go?

N: In general, more consistency for foundational ADTs should be sought so that the available types conform to common understanding of roles and complexity classes.

  - map
  - vector
  - list
  - cons

Also, mutable and immutable structures should be distinguished

R: Replace -unsafe with -safe?

bounded (minvalue maxvalue) is kind of like hash in that i'ts ring-0 or lower order

\section{Quasar Notes, Late July}

MPFR dependency is annoying because it will tend to crash you out if
you have a standard SBCL and run the test suites.

Recommendation: move big float (and associated tests) to secondary library.

Maybe 'math' (and all of its subpackages) is the 'premiere' secondary
library. What in primary might depend on it?

Concrete syntax: (, {, [ .. can it be done?

\end{document}
